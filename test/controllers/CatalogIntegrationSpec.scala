package controllers

import play.api.test.Helpers._
import play.api.test._
import play.api.libs.json._
import java.net.URI
import java.util.UUID

import _root_.util.Fixtures
import dao.Tables._
import _root_.util.DBIOUtil._
import Writables.jsonWritable
import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}
import org.scalatestplus.play.BaseOneAppPerSuite
import play.api.libs.json.{JsObject, Json}
import CatalogController.{CatalogListResponse, CatalogReq, reqRespFormat}
import controllers.helpers.CrudlActions.PagedResponse

class CatalogIntegrationSpec extends Fixtures with BaseOneAppPerSuite with TableDrivenPropertyChecks {

  import profile.api._
  import Fixtures.pagedResponseReads

  "CatalogController: positive cases" should {

    "show catalog" in {
      val c = createCatalog()
      val cid = c.catalogId
      val show = route(app, FakeRequest(GET, s"/catalogs/$cid")).get
      status(show) mustBe OK
      contentType(show) mustBe Some("application/json")
      contentAsJson(show) mustBe
        Json.parse(
          s"""{"name":"${c.name.get}","backendConfigId":null, "id":"${c.catalogId}" ,"description":"${c.description.get}"}""")
    }

    "delete catalog" in {
      val c = createCatalog()
      val cid = c.catalogId
      val delete = route(app, FakeRequest(DELETE, s"/catalogs/$cid")).get

      // check response
      status(delete) mustBe OK
      // check record has been removed
      await(Catalogs.filter(_.catalogId === cid).result.headOption.run(db)) mustBe None
    }

    "list catalogs" in {
      val c1 = createCatalog()
      val c2 = createCatalog()
      val list = route(app, FakeRequest(GET, "/catalogs")).get

      // check response
      status(list) mustBe OK
      contentType(list) mustBe Some("application/json")
      contentAsJson(list).as[PagedResponse[CatalogReq]].data mustBe Seq(c1, c2).map(CatalogReq.fromRow)
    }
    "list pagination" in {
      testPagination[CatalogReq](app, None, "catalogs", _ => createCatalog(), () => truncate("catalogs"))
    }

    "update catalog" in {
      val c = createCatalog()
      val cid = c.catalogId
      // id is ignored by controller in case of update (tradeoff for case class reusage, think of changing that)
      val upd = CatalogReq(Some("Foo"), Some("new description"), Some(UUID.randomUUID()))

      val update = route(app, FakeRequest(PUT, s"/catalogs/$cid").withBody(upd)).get

      status(update) mustBe OK
      contentType(update) mustBe Some("application/json")
      contentAsJson(update) mustBe
        Json.parse(
          s"""{"name":"Foo", "backendConfigId":null, "id":"${c.catalogId}","description":"${upd.description.get}"}""")
    }

    "create catalog" in {
      def fields(r: CatalogReq) =
        new TableFor2("fieldName" -> "value",
                      Json
                        .obj(
                          "description" -> r.description.get,
                          "name" -> r.name.get,
                          "id" -> r.id
                        )
                        .value
                        .toSeq: _*)

      //user provided id
      val cr = CatalogReq(Some("Foo"), Some("new description"), Some(UUID.randomUUID()))
      val create = route(app, FakeRequest(POST, s"/catalogs").withBody(cr)).get

      status(create) mustBe CREATED
      contentType(create) mustBe Some("application/json")
      val content = contentAsJson(create).as[JsObject]

      (content \ "description").validate[String] mustBe JsSuccess(cr.description.get)
      (content \ "name").validate[String] mustBe JsSuccess(cr.name.get)
      (content \ "id").validateOpt[UUID] mustBe JsSuccess(cr.id)

      //autogenerated id
      val create1Auto = route(app,
                              FakeRequest(POST, s"/catalogs")
                                .withJsonBody(Json.obj("name" -> cr.name, "description" -> cr.description))).get

      status(create1Auto) mustBe CREATED
      contentType(create1Auto) mustBe Some("application/json")
      val contentAuto = contentAsJson(create1Auto).as[JsObject]

      (content \ "description").validate[String] mustBe JsSuccess(cr.description.get)
      (content \ "name").validate[String] mustBe JsSuccess(cr.name.get)
      (contentAuto.value contains "id") mustBe true

    }
  }

  "CatalogController: negative cases" should {
    "return NOT_FOUND if catalog does not exist during show, update, delete" in {
      // a non-existent id
      val id = UUID.randomUUID()
      val show = route(app, FakeRequest(GET, s"/catalogs/$id")).get
      val update = {
        val upd = CatalogReq(None, None)
        route(app, FakeRequest(PUT, s"/catalogs/$id").withBody(upd)).get
      }
      val delete = route(app, FakeRequest(DELETE, s"/catalogs/$id")).get

      status(show) mustBe NOT_FOUND
      contentType(show) mustBe Some("application/json")

      status(update) mustBe NOT_FOUND
      contentType(show) mustBe Some("application/json")

      status(delete) mustBe NOT_FOUND
      contentType(show) mustBe Some("application/json")
    }

    "return BAD_REQUEST when using invalid catalog id" in {
      // an invalid id
      val id = "bar"

      val show = route(app, FakeRequest(GET, s"/catalogs/$id")).get
      status(show) mustBe BAD_REQUEST
      contentAsString(show) mustBe """{"errors":["Cannot parse parameter id as UUID: Invalid UUID string: bar"]}"""
    }

    "return UNPROCESSABLE_ENTITY when trying to delete catalog linked to schemas or datasources" in {
      val c = createCatalog()
      val cid = c.catalogId
      val ds = createDataSource(cid, "ds", Map("url" -> "jdbc:i.il"))
      val s = createSchema(cid, emptyPsl("s"), Seq())

      val delete = route(app, FakeRequest(DELETE, s"/catalogs/$cid")).get
      status(delete) mustBe UNPROCESSABLE_ENTITY
      contentAsString(delete) mustBe s"""{"errors":["Cannot delete catalog $cid. Reason: [Used by datasources:[ds],Used by schemas:[s]]"]}"""
    }

    "return UNPROCESSABLE_ENTITY when trying to create catalog with duplicate id" in {
      val c = createCatalog()
      val cid = c.catalogId
      val ds = createDataSource(cid, "ds", Map("url" -> "jdbc:i.il"))
      val s = createSchema(cid, emptyPsl("s"), Seq())

      val cr = CatalogReq(Some("Foo"), Some("new description"), Some(cid))
      val create = route(app, FakeRequest(POST, s"/catalogs").withBody(cr)).get
      contentAsJson(create) mustBe Json.parse(
        s"""{"errors":["Cannot create Catalog. Reason: Catalog '$cid' already exists, Catalog id must be globally unique"]}"""
      )
      status(create) mustBe UNPROCESSABLE_ENTITY
    }
  }
}
